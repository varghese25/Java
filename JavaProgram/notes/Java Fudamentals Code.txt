Java Type Casting

Type casting is when you assign a value of one primitive data type to another type.

In Java, there are two types of casting:

Widening Casting (automatically) - converting a smaller type to a larger type size
byte -> short -> char -> int -> long -> float -> double

Narrowing Casting (manually) - converting a larger type to a smaller size type
double -> float -> long -> int -> char -> short -> byte



Ex1 Widening Casting

public class Main {
public static void main(String[] args) {
int myInt = 10;
double myDouble = myInt; // Automatic casting: int to double
System.out.println(myInt);
System.out.println(myDouble);
 }
}

Ex2 Narrowing Casting (manually) 
public class Main {
public static void main(String[] args) {
double myDouble = 10.98; // Manual casting: double to Int
int myInt = (int) myDouble;
System.out.println(myDouble); // Output 10.98
System.out.println(myInt); // 10
}
 }





String Length - txt.length()
Ex1.
public class Main {
 public static void main(String[] args) {
 String txt = "Varghese Baby";
 System.out.println("The length of the text:" + txt.length()); // OutPut The length of the text:13
 }
  }


String - toUpperCase() & toLowerCase()

public class Main {
 public static void main(String[] args) {
 String txt = "Varghese Baby";
 System.out.println("The length of the text:" + txt.length());
 System.out.println(txt.toUpperCase()); // Out Put VARGHESE BABY 
 System.out.println(txt.toLowerCase()); // OutPut VARGHESE BABY varghese baby
 }
  }


String - indexOf

public class Main {
 public static void main(String[] args) {
 String txt = "Varghese Baby";
 System.out.println("The length of the text:" + txt.length());
 System.out.println(txt.toUpperCase());
 System.out.println(txt.toLowerCase());
 System.out.println(txt.indexOf("Baby")); Out Put from Varghese Baby 9
 }
  }

 Java counts positions from zero.
0 is the first position in a string, 1 is the second, 2 is the third ...



IF Else

public class Main{
public static void main(String[] args) {
int myAge = 30;
int votingAge = 18;
 if (myAge >=votingAge) 
 {
 System.out.println("Old Enough to Vote!!");
 }
 else 
 {
 System.out.println("Not old Enough to Vote!!");
 }
  } 
  }



else if 

public class Main {
public static void main (String[] args) {
int time = 20;
 if (time < 15) // 1st Condition False
 {
 System.out.println("Good Morning!!!!");
 }
 else if (time < 14) // 2nd Condition False
 {
 System.out.println("Good Noon!!");
 }
 else // Print the Statement As out put Good Eve!!
 {
 System.out.println("Good Eve!!");
 }
 }
 }



if else can short hand using ternary operater// variable = (condition) ? expressionTrue :  expressionFalse;

public class Main {
public static void main(String[] args) {
int time = 20;
String result;
result = (time < 15) ? "Good Morning" : "Good Evening"; // variable = (condition) ? expressionTrue :  expressionFalse;
System.out.println(result);
}
}


switch Case --- Instead of writing many if..else statements, you can use the switch statement.

The switch statement selects one of many code blocks to be executed:


public class Main {
public static void main(String[] args) {
int day = 5;
switch (day) { // Expression 
case 1:
System.out.println("Monday"); // Code block
break;
case 2:
System.out.println("Tuesday");
break;
case 3:
System.out.println("Weneday");
break;
case 4:
System.out.println("Thursday");
break;
case 5:
System.out.println("Friday"); // out Put will Friday 
break;
}
}
}

Switch Case  Default (The default keyword specifies some code to run if there is no case match:)

public class Main {
public static void main(String[] args) {
int day =4;
switch (day) {
case 6: 
System.out.println("Today is Saturday");
break;
case 7:
System.out.println("Today is Sunday");
break;
default:
System.out.println(" Weekenday"); // Out Put willbe WeekEnd The default keyword specifies some code to run if there is no case match: 
}
}
}




While loop ---> (While Loop evaluates the condition first and then executes the statement)


public class Main {
public static void main(String[] args) {
int i = 0;
while (i < 5) 
{
System.out.println(i);
i++;
}
}
}  Out Put // 0,1,2,3,4


Do while ---> (Do-While first executes the statements and then evaluates the condition.)

public class Main {
  public static void main(String[] args) {
    int i = 0;
    do {
      System.out.println(i);
      i++;
    }
    while (i < 5);  
  }
}
  Out Put // 0,1,2,3,4




For Loop --> 
public class Main {
public static void main(String [] args) {
for (int i=0; i < 5; i++) 
{
System.out.println(i);
}
 }
  } // Out Loop 0,1,2,3,4



Arrary 

public class Main {
  public static void main(String[] args) {
  int[] myNum = {100,200, 300}; // arry list 
  System.out.println(myNum[2]); // OutPut will be 300 Because Java index start from "0"
  }
  }



Change an Array Element 

public class Main {
 public static void main(String[] args) {
 String [] fruits = {"Apple","Orange", "SugarCane"}; // Arry
 fruits[2] = "RedBerry"; // Replaced Redberry in the place of SugarCane Change of Element
 System.out.println(fruits[2]); // OutPut RedBerry
 }
  }

Array Length


public class Main {
 public static void main(String[] args) {
 String [] fruits = {"Apple","Orange", "SugarCane"}; // Length will 3
 System.out.println(fruits.length); // Out Put will be 3
 }
  }



public class Main {
 public static void main(String[] args) {
 String [] cars = {"Volvo", "BMW", "Ford", "Mazda"}; // Length
 for(int i=0; i<cars.length; i++)
 System.out.println(cars[i]); // If you remove [i] simly put  System.out.println(i) // Can find Index 0, 1,2,3
 }
} 
Out Put  
Volvo
BMW 
Ford
Mazda

Loop Through an Array with For-Each (The example above can be read like this: for each String element (called i - as in index) in cars, print out the value of i.

If you compare the for loop and for-each loop, you will see that the for-each method is easier to write, it does not require a counter (using the length property), and it is more readable)

public class Main {
public static void main(String[] args) {
String [] cars ={"Volvo", "BMW", "Ford", "Mazda"};
for (String i : cars) { //  It doesn't required lenght it much simpler way to write find the length of property
System.out.println(i);
}
 }

Out Put  
Volvo
BMW 
Ford
Mazda
ss


2 Deminisonal Arry

public class Main {
  public static void main(String[] args) {
    int[][] myNumbers = { {1, 2, 3, 4}, {5, 6, 7} }; Row & Colums 
    System.out.println(myNumbers[1][2]); // [1] -->is Second Row. [2] -> is column Index starts from "0 " // Out put is 7
  }
}

In Java Row starst from R0, R1 Vesces Versa
R0-> {1,2,3,4,5}
R1-> {6,7,8,9,10}
     C1.......C5

2D Arrary Change Element Values
public class Main {
public static void main(String[] args) {
int [][] num= {{1,2,3,4,5},{6,7,8,9,10}};
num[1][4]=1000;
System.out.println(num[1][4]); // Outputs 1000 instead of 7
} }

R0-> {1,2,3,4,5}
R1-> {6,7,8,9,10}
     C1.......C5




Loop Through a Multi-Dimensional Array

public class Main {
 public static void main(String[] args) {
  int [][] num = {{1,2,3,4,5},{6,7,8,9,10}};
  for(int row =0; row < num.length; row++) // Row length is two 
   {
  for(int col =0; col <num [row].length; col++) // Col length is 4, Meaning in first row col lenght is four 
   {
   System.out.print(num[row][col] + "\t");
   }
   System.out.println();
    }
      }
     }
Out Put

1	2	3	4	5	
6	7	8	9	10


public class Main {
 public static void main(String[] args) {
  int[][] num = {{1,2,3,4,5},{6,7,8,9,10}};
  num[1][4]=368; // Changed 10 to 368 
  for(int row=0; row < num.length; row++)
   {
   for(int col=0; col< num[row].length; col++)
    {
    System.out.print(num[row][col] + "\t");
    }
    System.out.println();
    }
     }
    }
Out Put
1	2	3	4	5	
6	7	8	9	368



METHOD-> A method is a block of code which only runs when it is called.You can pass data, known as parameters, into a method.
Methods are used to perform certain actions, and they are also known as functions. Why use methods? To reuse code: define the code once, and use it many times.



Inside main, call the myMethod() method:

public class Main {
 static void myMethod() { // Method
 System.out.println("I will become a Java developer!! By God Grace");
}
 public static void main(String[] args) 
  {
  myMethod(); // Inside main, call the myMethod() method:
  }
  }


OutPut
I will become a Java developer!! By God Grace




A method can also be called multiple times:

public class Main {
 static void myMethod() { // Method
 System.out.println("I will become a Java developer!! By God Grace");
}
 public static void main(String[] args) 
  {
  myMethod(); //  A method can also be called multiple times: 
  myMethod();
  myMethod();
  }
  }


OutPut
I will become a Java developer!! By God Grace
I will become a Java developer!! By God Grace
I will become a Java developer!! By God Grace


Parameters and Arguments

public class Main {
 static void myMethod(String fname) {
 System.out.println(fname + "Refsnes");
 }
 public static void main(String[] args) {
 
 myMethod("Liam  ");
 myMethod("Jenny ");
 myMethod("Anja  ");
  }
 } 


OUT PUT
Liam  Refsnes
Jenny Refsnes
Anja  Refsnes




Parameters and Arguments -
Return Values 


public class Main {
 static int myMethod(int x) {
 return 5+ x; // Return Value
 }
 public static void main(String[] args) {
 System.out.println(myMethod(100));
 }
 }

Out Put
105


sum of a method's two parameters:

public class Main {
 static int myMethod(int x, int y) {
 return x + y; // sum of a method's two parameters:
 }
  public static void main(String[] args) {
   System.out.println(myMethod(90 , 18));
   }
   }
 
OutPut
108



You can also store the result in a variable (recommended, as it is easier to read and maintain):

public class Main {
 static int myMethod(int x, int y) {
  return x * y ;
  }
   public static void main(String[] args) {
    int z = myMethod (4, 4);
    System.out.println(z);
    }
    }
OutPut
16


 Method with If...Else
It is common to use if...else statements inside methods:

public class Main {
 static void checkAge(int age)  // Data Type , Void completely emty suppose i your declared date type it should not return any value
  {
    if (age < 18)
     { 
    System.out.println("Access denied - You are not old enough!");
   }
    else {
    System.out.println("Access Granted - You are  old enough!");
    }
 }
  public static void main(String[] args) 
   {
   System.out.println(checkAge(20));
   }
    }


Java Method Overloading





Create an Object
In Java, an object is created from a class.

public class Main {// Class Name Main 
 int x = 200;
 int y = 100;
 public static void main(String[] args) {
  Main myObj = new Main(); // in this block we will call the (Main)  specify the class name, followed by the object name, and use the keyword new://
  System.out.println(myObj.x + myObj.y);
   }
    }
Out Put 300

You can create multiple objects of one class:

public class Main {
 int x = 51;
  public static void main(String[] args) {
   Main myObj1 = new Main();
   Main myObj2 = new Main();
   System.out.println(myObj1.x);
   System.out.println(myObj2.x);
   }
    }

Out Put
51
51



public class Main { // Class name is Main 
 int x = 10;  // Main class object called in second class
  }

public class Second { // Class name is second 
 public static void main(String[] args)
  {
   Main myObj1 = new Main(); // Here Main class object called 
   System.out.println(myObj1.x);
   }
    }

Out Put is 10




Modify Attributes
You can also modify attribute values:

Example
Set the value of x to 40:


public class Main {
 int x;
 public static void main(String[] args)
  {
   Main myObj = new Main();
   myObj.x = 40;
   System.out.println(myObj.x);
   }
    }

Out Put 40


Or override existing values:

public class Main {
 int x = 35;
  public static void main(String[] args)
   {
   Main myObj = new Main();
   myObj.x = 40; // Override x Value which was 35 changed to 40
   System.out.println(myObj.x);
    }
     }




If you don't want the ability to override existing values, declare the attribute as final: Example below

public class Main {
 final int x = 35; // If you don't want the ability to override existing values, declare the attribute as final//
  public static void main(String[] args)
   {
    Main myObj = new Main();
    myObj.x = 36; // will generate an error: cannot assign a value to a final variable
    System.out.println(myObj.x);
     }
      }
 
   OutPut 
Main.java:6: error: cannot assign a value to final variable x
    myObj.x = 25; 
         ^
1 error




Multiple Objects

public class Main {
 int x = 25;
  public static void main(String[] args)
   {
   Main myObj1 = new Main(); // Object 1
   Main myObj2 = new Main(); // Object 2
   myObj2.x =50;
   System.out.println(myObj1.x); //
   System.out.println(myObj2.x);
    }
     }


Out Put
25
50




Multiple Attributes
You can specify as many attributes as you want:

public class Main {
 String fname ="Evan"; // Attributes 1
 String mname = "Poulose"; // Attributes 2
 String lname = "Varghese"; // Attributes 3

 int Age = 05; // Attributes 4

  public static void main(String[] args) 
   {
   Main myObj = new Main();
   System.out.println("Name: " + myObj.fname+ " " + myObj.mname+" "+ myObj.lname);
   System.out.println("Age: " + myObj.Age);
    
   }
    }




Out Put
Name: Evan Poulose Varghese
Age: 5






Public :public, which can only be accessed by objects: Main myObj = new Main()

public class Main {
  int x = 5;

  public static void main(String[] args) {
    Main myObj = new Main(); // Object
    System.out.println(myObj.x);
  }
}

Static : static method, which means that it can be accessed without creating an object of the class, 
public class Main {
  static void myMethod() { 
    System.out.println("Hello World!");
  }

  public static void main(String[] args) {
    myMethod();
  }
}





Example
An example to demonstrate the differences between static and public methods:

public class Main {
  // Static method
  static void myStaticMethod() {
    System.out.println("Static methods can be called without creating objects");
  }

  // Public method
  public void myPublicMethod() {
    System.out.println("Public methods must be called by creating objects");
  }

  // Main method
  public static void main(String[] args) {
    myStaticMethod(); // Call the static method

    Main myObj = new Main(); // Create an object of MyClass
    myObj.myPublicMethod(); // Call the public method
  }
}




Access Methods With an Object 

// Create a Main class
public class Main {
 
  // Create a fullThrottle() method
  public void fullThrottle() {
    System.out.println("The car is going as fast as it can!");
  }

  // Create a speed() method and add a parameter
  public void speed(int maxSpeed) {
    System.out.println("Max speed is: " + maxSpeed);
  }

  // Inside main, call the methods on the myCar object
  public static void main(String[] args) {
    Main myCar = new Main();   // Create a myCar object
    myCar.fullThrottle();      // Call the fullThrottle() method
    myCar.speed(200);          // Call the speed() method
  }
}

// The car is going as fast as it can!
// Max speed is: 200






Using Multiple Classes: , it is a good practice to create an object of a class and access it in another class.Remember that the name of the java file should match the class name. In this example, we have created two files in the same directory:

Main.java
Second.java


Main.java

public class Main {
  public void fullThrottle() {
    System.out.println("The car is going as fast as it can!");
  }

  public void speed(int maxSpeed) {
    System.out.println("Max speed is: " + maxSpeed);
  }
}

Second.java

class Second {
  public static void main(String[] args) {
    Main myCar = new Main();     // Create a myCar object
    myCar.fullThrottle();      // Call the fullThrottle() method
    myCar.speed(200);          // Call the speed() method
  }
}



When both files have been compiled:

C:\Users\Your Name>javac Main.java
C:\Users\Your Name>javac Second.java

Run the Second.java file:

C:\Users\Your Name>java Second

And the output will be:

The car is going as fast as it can!
Max speed is: 200

------------------------------------
 constructor in Java

 is a special method that is used to initialize objects. The constructor is called when an object of a class is created. It can be used to set initial values for object attributes:
Note that the constructor name must match the class name, and it cannot have a return type (like void).
Also note that the constructor is called when the object is created.

All classes have constructors by default: if you do not create a class constructor yourself, Java creates one for you. However, then you are not able to set initial values for object attributes.





// Create a Main class
public class Main {
  int x;  // Create a class attribute

  // Create a class constructor for the Main class
  public Main() {
    x = 5;  // Set the initial value for the class attribute x
  }

  public static void main(String[] args) {
    Main myObj = new Main(); // Create an object of class Main (This will call the constructor)
    System.out.println(myObj.x); // Print the value of x
  }
}

// Outputs 5




Constructor Parameters
Constructors can also take parameters, which is used to initialize attributes.

The following example adds an int y parameter to the constructor. Inside the constructor we set x to y (x=y). When we call the constructor, we pass a parameter to the constructor (5), which will set the value of x to 5:

public class Main {
  int x;

  public Main(int y) {
    x = y;
  }

  public static void main(String[] args) {
    Main myObj = new Main(5);
    System.out.println(myObj.x);
  }
}

// Outputs 5



You can have as many parameters as you want:


public class Main {// class main
  int modelYear; 
  String modelName;

  public Main(int year, String name) { //Construstor Created and attributes created for Main  class
    modelYear = year;
    modelName = name;
  }

  public static void main(String[] args) {
    Main myCar = new Main(1969, "Mustang"); // Objects for main class
    System.out.println(myCar.modelYear + " " + myCar.modelName);
  }
}

// Outputs 1969 Mustang







Encapulation: Senestive Data Hidden
 
Person.Java

public class Person
 {
private String name;

 // Getter
public String getName()
{
return name;
}
//Setter;
public void setName(Strin newName)
{
this.name = newName;
}
}

myClass.Java
 
public class Main {
 public static void main(String[] args) 
 {
Person myObj = new Person();
myObj.setName("Varghese")
 System.out.println(myObj.getName());
}
} 
OutPut
Varghese



Package /Api

 import java.until.Scanner; 
 myClass {
 public static void main(String[] args)
  {
 Scanner myObj = new Scanner(Scanner.in);
 System.out.println("Enter UserName");
 String userName = myObj.nextLine(); // nextLine is a Method which read complete line
 System.out.println("UserName:"+ userName);
 }
} 
OutPut
Enter username
Varghese

Username is: Varghese


Inheritance
-----------


class Vehicle {
  protected String brand = "Ford";        // Vehicle attribute
  public void honk() {                    // Vehicle method
    System.out.println("Tuut, tuut!");
  }
}

class Car extends Vehicle {
  private String modelName = "Mustang";    // Car attribute
  public static void main(String[] args) {

    // Create a myCar object
    Car myCar = new Car();

    // Call the honk() method (from the Vehicle class) on the myCar object
    myCar.honk();

    // Display the value of the brand attribute (from the Vehicle class) and the value of the modelName from the Car class
    System.out.println(myCar.brand + " " + myCar.modelName);
  }
}






Java Polymorphism
Polymorphism means "many forms", and it occurs when we have many classes that are related to each other by inheritance.

class Animal {
 public void animalSound()
  {
   System.out.println("The animal makes a sound");
   }
    }
    
class dog extends Animal {
public void animalSound() {
System.out.println("The dog says: bow wow");
}
 }
 
class cat extends Animal {
public void animalSound() {
System.out.println("The cat says: Mee Yow");
}
 }
 
class Main {
 public static void main(String[] args) {
 Animal myAnimal = new Animal();
 Animal mydog = new dog();
 Animal mycat = new cat();
 
 myAnimal.animalSound();
 mydog.animalSound();
 mycat.animalSound();
 
 }
  }


OutPut

The animal makes a sound
The dog says: bow wow
The cat says: Mee Yow



Java Inner Classes: 
In Java, it is also possible to nest classes (a class within a class). The purpose of nested classes is to group classes that belong together, which makes your code more readable and maintainable.

To access the inner class, create an object of the outer class, and then create an object of the inner class:

class outer {
 int x = 5;
class inner {
 int y = 4;
}
 }
  class Main {
  public static void main(String[] args) {
  outer myOuter = new outer(); // myOuter Object 
  outer.inner myInner = myOuter.new inner(); // like Sql Joins connect the class outer.inner create Object myInner = Object of myOuter.new inner class
  System.out.println(myInner.y * myOuter.x);
}
 }



Private Inner Class
Unlike a "regular" class, an inner class can be private or protected. If you don't want outside objects to access the inner class, declare the class as private:



class outer {
 int x = 5;
private class inner { // inner class can be private or protected it will through error below is Error Msg
 int y = 4;
}
 }
  class Main {
  public static void main(String[] args) {
  outer myOuter = new outer(); // myOuter Object 
  outer.inner myInner = myOuter.new inner(); // like Sql Joins connect the class outer.inner create Object myInner = Object of myOuter.new inner class
  System.out.println(myInner.y * myOuter.x);
}
 }


Error Msg
Main.java:10: error: outer.inner has private access in outer
  outer.inner myInner = myOuter.new inner();



Static Inner Class
An inner class can also be static, which means that you can access it without creating an object of the outer class:

class Outer {
 int x = 10;
static class Inner { // inner class is Static we access without creating object of the outer class 
 int y =25;
}
 }
  public class Main {
  public static void main(String[] args) {
  Outer.Inner myInner = new Outer.Inner();
  System.out.println(myInner.y);
  }
   }


OutPut
25


Access Outer Class From Inner Class
One advantage of inner classes, is that they can access attributes and methods of the outer class:

class outerClass {
 int x =10;
class innerClass {
 public int innerMethod(){
  return x ;
  }
   } 
    }
    
 public class Main {
 public static void main(String[] args) {
 outerClass myOuter = new outerClass();
 outerClass.innerClass myInner = myOuter.new innerClass();
 System.out.println(myInner.innerMethod());
 }
  }


14-03-24 Prepared

Abstract Classes and Methods
Data abstraction is the process of hiding certain details and showing only essential information to the user.
Abstraction can be achieved with either abstract classes or interfaces

The abstract keyword is a non-access modifier, used for classes and methods:

Abstract class: is a restricted class that cannot be used to create objects (to access it, it must be inherited from another class).

Abstract method: can only be used in an abstract class, and it does not have a body. The body is provided by the subclass (inherited from).
An abstract class can have both abstract and regular methods:

// Abstract class
abstract class Car {
// Abstract method (does not have a body)
 public abstract void engineSound(); 
  // Regular method
 public void sound() {
 System.out.println("Vroom");
}
 }
 // Subclass (inherit from  Car)
class Audi extends Car {
 public void engineSound() {
 // The body of EngineSound() is provided here
 System.out.println("The audi honk: Pa Pammm");
}
 }
   
class Main{
 public static void main(String[] args) {
 Audi myAudi = new Audi(); // Create Object
 myAudi.engineSound();
 myAudi.sound();
}
 }


Interfaces
Another way to achieve abstraction in Java, is with interfaces.

An interface is a completely "abstract class" that is used to group related methods with empty bodies:


// Interface
interface Animal {
  public void animalSound(); // interface method (does not have a body)
  public void sleep(); // interface method (does not have a body)
}

// Pig "implements" the Animal interface
class Pig implements Animal {
  public void animalSound() {
    // The body of animalSound() is provided here
    System.out.println("The pig says: wee wee");
  }
  public void sleep() {
    // The body of sleep() is provided here
    System.out.println("Zzz");
  }
}

class Main {
  public static void main(String[] args) {
    Pig myPig = new Pig();  // Create a Pig object
    myPig.animalSound();
    myPig.sleep();
  }
}


outPut
The pig says: wee wee
Zzz

To access the interface methods, the interface must be "implemented" (kinda like inherited) by another class with the implements keyword (instead of extends). The body of the interface method is provided by the "implement" class:


Notes on Interfaces:
Like abstract classes, interfaces cannot be used to create objects (in the example above, it is not possible to create an "Animal" object in the MyMainClass)
Interface methods do not have a body - the body is provided by the "implement" class
On implementation of an interface, you must override all of its methods
Interface methods are by default abstract and public
Interface attributes are by default public, static and final
An interface cannot contain a constructor (as it cannot be used to create objects)
Why And When To Use Interfaces?
1) To achieve security - hide certain details and only show the important details of an object (interface).

2) Java does not support "multiple inheritance" (a class can only inherit from one superclass). However, it can be achieved with interfaces, because the class can implement multiple interfaces. Note: To implement multiple interfaces, separate them with a comma (see example below).



Multiple Interfaces
To implement multiple interfaces, separate them with a comma:

interface FirstMethod {
 public void methodOne(); // interface method
 }
interface SecondMethod {
 public void methodTwo();// interface method
 }
 class Demo implements FirstMethod,SecondMethod // in this demo class both interface called with comma
  {
  public void methodOne() // if its (public void) object not required. if its public static void object required 
   {
   System.out.println("Some text..."); // method is created with body
   }
   public void methodTwo()
   {
   System.out.println("Some other text...");// method is created with body
   }
    }
    class Main {
    public static void main(String[] args) 
    {
    Demo myDemo = new Demo(); // Object created for demo
    myDemo.methodOne();
    myDemo.methodTwo();
    }
    }
outPut
Some text...
Some other text...




Enum is short for "enumerations", which means "specifically listed"

An enum is a special "class" that represents a group of constants (unchangeable variables, like final variables).

To create an enum, use the enum keyword (instead of class or interface), and separate the constants with a comma. Note that they should be in uppercase letters:

enum Level
 {
LOW, MEDIUM, HIGH
 }
 class Main {
 public static void main(String[] args) {
 Level myVar = Level.HIGH;
 System.out.println(myVar);
 }
  }
OutPut
HIGH


Enum inside a Class
You can also have an enum inside a class:

class Main {
 enum Level 
{ 
 Low, medium , High
 }
 public static void main(String[] args)
 {
 Level myVar = Level.Low;
 System.out.println(myVar);
 }
  }

Output
Low


Enum in a Switch Statement
Enums are often used in switch statements to check for corresponding values:

enum Level 
 {
 Red,
 Green,
 Blue
 }
  class Main 
  {
  public static void main(String[] args)
  {
  Level myVar = Level.Red;
  switch(myVar)
  {
  case Red:
  System.out.println("Red Alter");
  break;
  case Green:
  System.out.println("Green Alter");
  break;
  case Blue:
  System.out.println("Blue Alter");
  }
  }
  }

OutPut
Red Alter



Loop Through an Enum

The enum type has a values() method, which returns an array of all enum constants. This method is useful when you want to loop through the constants of an enum:


enum Stage 
 {
 Red,
 Green,
 Blue
 }
  class main {
   public static void main(String[] args) 
   {
   for (Stage myVar : Stage.values()) // values is used to display the array list red,green,blue
   {
   System.out.println(myVar);
   }
    }
     }


OutPut
Red
Green
Blue

Difference between Enums and Classes
An enum can, just like a class, have attributes and methods. The only difference is that enum constants are public, static and final (unchangeable - cannot be overridden).

An enum cannot be used to create objects, and it cannot extend other classes (but it can implement interfaces).

Why And When To Use Enums?
Use enums when you have values that you know aren't going to change, like month days, days, colors, deck of cards, etc.





15-03-2024
Java User Input: The Scanner class is used to get user input, and it is found in the java.util package.

To use the Scanner class, create an object of the class and use any of the available methods found in the Scanner class documentation. In our example, we will use the nextLine() method, which is used to read Strings:

Below code executed in online compiler
https://www.programiz.com/java-programming/online-compiler/ 

import java.util.Scanner; // import the Scanner class 

class Shannon {
     public static void main(String[] args) {
         Scanner myObj = new Scanner(System.in);
         System.out.println("Enter username");
          // Enter username and press Enter
         String userName;
        userName  = myObj.nextLine();
        System.out.println("name is:" + userName);
     }
}

Out Put
Enter username
Varghese
name is: Varghese


Java User Input: Input Types
nextLine();
nextInt();
nextDouble(); // used in below program code executed in the  www.programiz.com. some more  input type are there
nextBoolean();
nextByte();
nextFloat();
nextLong()
nextShort()	


import java.util.Scanner;
class Evan {
    public static void main(String[] args) {
        Scanner myObj = new Scanner(System.in);
        System.out.println("Enter car, model and price");
        String car = myObj.nextLine(); // Input type is string 
        int model = myObj.nextInt(); // Input type is int
        double price = myObj.nextDouble(); // Intput type is double
        System.out.println("car name is:"+ car);
        System.out.println("model year is:"+ model);
        System.out.println("price is:"+ price);
    }
}









Java Date and Time
Java Dates
Java does not have a built-in Date class, but we can import the java.time package to work with the date and time API. The package includes many date and time classes. For example:

Class	Description
LocalDate	Represents a date (year, month, day (yyyy-MM-dd))
LocalTime	Represents a time (hour, minute, second and nanoseconds (HH-mm-ss-ns))
LocalDateTime	Represents both a date and a time (yyyy-MM-dd-HH-mm-ss-ns)
DateTimeFormatter	Formatter for displaying and parsing date-time objects


Display Current Date
To display the current date, import the java.time.LocalDate class, and use its now() method:



import java.time.LocalDate;
class Tiju {
     public static void main(String[] args) {
         LocalDate myTime = LocalDate.now();
         System.out.println(myTime);
     }
}

OutPut
2024-03-16



Display Current Time
To display the current time (hour, minute, second, and nanoseconds), import the java.time.LocalTime class, and use its now() method:

import java.time.LocalTime;  // import the LocalTime class

public class Main {  
  public static void main(String[] args) {  
    LocalTime myObj = LocalTime.now();
    System.out.println(myObj);
  }  
}  

OutPut
22:52:00.205550





Display Current Date and Time
To display the current date and time, import the java.time.LocalDateTime class, and use its now() method:




import java.time.LocalDateTime; // import the LocalDateTime class

public class Main {
  public static void main(String[] args) {
    LocalDateTime myObj = LocalDateTime.now();
    System.out.println(myObj);
  }
}
OutPut
2024-03-15T22:52:00.206533


Formatting Date and Time
The "T" in the example above is used to separate the date from the time. You can use the DateTimeFormatter class with the ofPattern() method in the same package to format or parse date-time objects. The following example will remove both the "T" and nanoseconds from the date-time:


import java.time.LocalDateTime; // Import the LocalDateTime class
import java.time.format.DateTimeFormatter; // Import the DateTimeFormatter class

public class Main {
  public static void main(String[] args) {
    LocalDateTime myDateObj = LocalDateTime.now();
    System.out.println("Before formatting: " + myDateObj);
    DateTimeFormatter myFormatObj = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");

    String formattedDate = myDateObj.format(myFormatObj);
    System.out.println("After formatting: " + formattedDate);
  }
}

The output will be:

Before Formatting: 2024-03-15T23:26:36.903583
After Formatting: 15-03-2024 23:26:36





18-03-2024

Java ArrayList
The ArrayList class is a resizable array, which can be found in the java.util package.

The difference between a built-in array and an ArrayList in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an ArrayList whenever you want. The syntax is also slightly different:


import java.util.ArrayList; \\ Array Package. import the ArrayList class
public class Main{
public static void main(String[] args) {
ArrayList <String> cars = new ArrayList<String>(); \\Inilizating array , Create an ArrayList object
cars.add("BMW"); \\add method used to add cars brad
cars.add("VOLVO");
cars.add("Pagani");
System.out.println(cars); \\print the list of cars in the array
}
 }



Out Put
[BMW, VOLVO, Pagani]






Access an Item (Particular Item)
To access an element in the ArrayList, use the get() method and refer to the index number:


import java.util.ArrayList;
public class Main{
public static void main(String[] args) {
ArrayList<String> Cars = new ArrayList<String>();
Cars.add("Vovlo");
Cars.add("Mazda");
Cars.add("BMW");
Cars.add("Audi");
System.out.println(Cars.get(3)); // Get method is used .In array list audi is number 3 postion in this way access the details
}
}

OutPut is Audi

Note: Remember: Array indexes start with 0: [0] is the first element. [1] is the second element, etc.




Change an Item( Add a item set() method)
To modify an element, use the set() method and refer to the index number:
 
import java.util.ArrayList;
public class Main {
 public static void main(String[] args) {
  ArrayList<String> Cars= new ArrayList<String>();
  Cars.add("Opel");
  Cars.add("BMW");
  Cars.add("Ford");
  Cars.add("Mazda");
  Cars.set(0,"Volvo"); // set method replace the zero positon opel replaced to Volvo is added in the array 
  System.out.println(Cars);
  }
   }
   
   OutPut 
   [Volvo, BMW, Ford, Mazda]




Remove an Item
To remove an element, use the remove() method and refer to the index number:


import java.util.ArrayList;
public class Main{
 public static void main(String[] args) {
  ArrayList<String> Cars = new ArrayList<String>();
  Cars.add("BMW");
  Cars.add("Honda");
  Cars.add("Audi");
  Cars.add("TATA"); // from the arry list "TATA" position is 3rd its removed from list\\
  Cars.add("Volvo");
  Cars.remove(3); // remove method used 
  System.out.println(Cars);
  }
   }
   
 OutPut
 [BMW, Honda, Audi, Volvo]





To remove all the elements in the ArrayList, use the clear() method:
import java.util.ArrayList;

public class Main { 
  public static void main(String[] args) { 
    ArrayList<String> cars = new ArrayList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    cars.clear(); // clear all the record in the array
    System.out.println(cars);
  } 
}



Output
[]


Loop Through an ArrayList
Loop through the elements of an ArrayList with a for loop, and use the size() method to specify how many times the loop should run:

import java.util.ArrayList;
public class Main{
 public static void main(String[] args) {
 ArrayList<String> cars = new ArrayList<String>();
 cars.add("Volvo");
 cars.add("BMW");
 cars.add("Ford");
 cars.add("Mazda");
 for(int i=0; i <cars.size(); i++) // size method used so it willdisplay the arrayList
 {
  System.out.println(cars.get(i));
  }
  }
  }
  

OutPut


Volvo
BMW
Ford
Mazda 

Loop Method

0 - Volvo it will increment
1 - BMW 
2 - Ford
3 - Mazda



For-each Loop
You can also loop through an ArrayList with the for-each loop:


import java.util.ArrayList;
public class Main {
public static void main(String[] args) {
ArrayList<String> cars = new ArrayList<String>();
cars.add("Volvo");
cars.add("BMW");
cars.add("Ford");
cars.add("Mazda");
for(String i: cars) // For each loop syntax for(dataType item : array) {)
 {
 System.out.println(i);
 }
  }
   }
   
   OutPut
   Volvo
BMW
Ford
Mazda
   
For Each used integers

import java.util.ArrayList;
public class Main {
 public static void main(String[] args){
  ArrayList<Integer> Mynumbers = new ArrayList<Integer>(); // intgers used
  Mynumbers.add(5);
  Mynumbers.add(150);
  Mynumbers.add(11);
  Mynumbers.add(54);
  for(int i : Mynumbers) // For each Loop
   {
    System.out.println(i);
    }
     }
      }
      
      OutPut
      5
      150
      11
      54



Sort an ArrayList :
Another useful class in the java.util package is the Collections class, which include the sort() method for sorting lists alphabetically or numerically:


Sort an ArrayList : Numberically Expl 1
import java.util.ArrayList;
import java.util.Collections; // Collections package used to sort OrderList
 
 public class Main {
 public static void main(String[] args){
  ArrayList<Integer> Mynumbers = new ArrayList<Integer>(); // intgers used
  Mynumbers.add(5);
  Mynumbers.add(150);
  Mynumbers.add(11);
  Mynumbers.add(54);
  Collections.sort(Mynumbers); // Collections method used sort Mynumbers object in orderList
  for(int i : Mynumbers) // For each Loop
   {
    System.out.println(i);
    }
     }
      }
OutPut

5
11
54
150

Sort an ArrayList : Alpabatical Expl 2
import java.util.ArrayList;
import java.util.Collections; // Collections package used to sort OrderList
 
 public class Main {
 public static void main(String[] args){
  ArrayList<String> fruit = new ArrayList<String>(); // String used
  fruit.add("Orange");
  fruit.add("Guva");
  fruit.add("Sugar Cane");
  fruit.add("Apple");
  Collections.sort(fruit); // Collections method used sort fruit object in orderList
  for(String i : fruit) // For each Loop
   {
    System.out.println(i);
    }
     }
      }

OutPut i is
Apple
Guva
Orange
Sugar Cane






Java LinkedList
 The LinkedList class is almost identical to the ArrayList:

When To Use
ArrayList: for storing and accessing data. (Key word: add(), get(),set(), remove(), clear(), size(), sort()
LinkedList: to manipulate data. (Key word: addFirst(), addLast(), removeFirst(),removeLast(),getFirst(), getLast())

import java.util.LinkedList;// linkedList package

public class Main {
  public static void main(String[] args) {
    LinkedList<String> cars = new LinkedList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    
    // Use addFirst() to add the item to the beginning
    cars.addFirst("Mazda");
    System.out.println(cars);
  }
}


OutPut

[Mazda, Volvo, BMW, Ford]


import java.util.LinkedList;

public class Main {
  public static void main(String[] args) {
    LinkedList<String> cars = new LinkedList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    
    // Use addLast() to add the item to the end
    cars.addLast("Mazda");
    System.out.println(cars);
  }
}
OutPut
[Volvo, BMW, Ford, Mazda]



import java.util.LinkedList;

public class Main {
  public static void main(String[] args) {
    LinkedList<String> cars = new LinkedList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    
    // Use removeFirst() remove the first item from the list
    cars.removeFirst();
    System.out.println(cars);
  }
}
OutPut
[BMW, Ford, Mazda]




import java.util.LinkedList;

public class Main {
  public static void main(String[] args) {
    LinkedList<String> cars = new LinkedList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    
    // Use removeLast() remove the last item from the list
    cars.removeLast();
    System.out.println(cars);
  }
}
OutPut
[Volvo, BMW, Ford]




import java.util.LinkedList;

public class Main {
  public static void main(String[] args) {
    LinkedList<String> cars = new LinkedList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    
    // Use getFirst() to display the first item in the list
    System.out.println(cars.getFirst());
  }
}
OutPut
VolVo


import java.util.LinkedList;

public class Main {
  public static void main(String[] args) {
    LinkedList<String> cars = new LinkedList<String>();
    cars.add("Volvo");
    cars.add("BMW");
    cars.add("Ford");
    cars.add("Mazda");
    
    // Use getLast() to display the last item in the list
    System.out.println(cars.getLast());
  }
}
OutPut
Mazda




How the ArrayList works
The ArrayList class has a regular array inside it. When an element is added, it is placed into the array. If the array is not big enough, a new, larger array is created to replace the old one and the old one is removed.

How the LinkedList works
The LinkedList stores its items in "containers." The list has a link to the first container and each container has a link to the next container in the list. To add an element to the list, the element is placed into a new container and that container is linked to one of the other containers in the list.




19-03-2024

Java HashMap
In the ArrayList chapter, you learned that Arrays store items as an ordered collection, and you have to access them with an index number (int type). A HashMap however, store items in "key/value" pairs, and you can access them by an index of another type (e.g. a String).
One object is used as a key (index) to another object (value). It can store different types: String keys and Integer values, or the same type, like: String keys and String values:


Add Items
The HashMap class has many useful methods. For example, to add items to it, use the put() method:

import java.util.HashMap; // Import the HashMap class
 public class Main {
 public static void main(String[] args) {
 // Create a HashMap object called capitalCode
 HashMap<String, Integer> capitalCode = new HashMap<String, Integer>();//Key is String , Value is integer
 capitalCode.put("India",91); // Add items put method used
 capitalCode.put("USA",1);
 capitalCode.put("Norway",25);
 capitalCode.put("England",56);
 System.out.println(capitalCode);
 }
  }
OutPut
{USA=1, Norway=25, England=56, India=91}



import java.util.HashMap; // Import the HashMap class
 public class Main {
 public static void main(String[] args) {
 // Create a HashMap object called capitalCode
 HashMap<String, String> capitalCode = new HashMap<String, String>();//Key is String , Value is String
 capitalCode.put("India","NewDelhi");
 capitalCode.put("USA","Washinton DC");
 capitalCode.put("Norway","OSOL");
 capitalCode.put("England","London");
 System.out.println(capitalCode);
 }
  }
OutPut
{USA=Washinton DC, Norway=OSOL, England=London, India=NewDelhi}






Access an Item
To access a value in the HashMap, use the get() method and refer to its key:

import java.util.HashMap;
 public class Main {
 public static void main(String[] args) {
 HashMap<String, String> Capital = new HashMap();
 Capital.put("India", "New Delhi");
 Capital.put("China", "Bejing");
 Capital.put("England", "Londan");
 Capital.put("French", "Paris");
   System.out.println(Capital.get("India")); // get() method used key to access the value ex India is key value is New Delhi
   }
    }
 OutPut
 New Delhi



Remove an Item
To remove an item, use the remove() method and refer to the key:

import java.util.HashMap;
 public class Main {
  public static void main(String[] args) {
  HashMap<String, Float> captialTemp = new HashMap();
  captialTemp.put("India", 25.1F);
  captialTemp.put("China", 24.1F);
  captialTemp.put("UK", 23.1F);
  captialTemp.put("USA", 21.1F);
  captialTemp.remove("India"); // remove() used to remove the key & its value 
  System.out.println(captialTemp);
   }
    }
  
 
   Out Put
  {USA=21.1, China=24.1, UK=23.1, India=25.1} // Actual OutPut
  {USA=21.1, China=24.1, UK=23.1} //  Removed india from the list


To remove all items, use the clear() method:

import java.util.HashMap;
 public class Main {
  public static void main(String[] args) {
  HashMap<String, Float> captialTemp = new HashMap();
  captialTemp.put("India", 25.1F);
  captialTemp.put("China", 24.1F);
  captialTemp.put("UK", 23.1F);
  captialTemp.put("USA", 21.1F);
  captialTemp.clear(); // clear all the list 
  System.out.println(captialTemp);
   }
    }
    
    
    OutPut
    {USA=21.1, China=24.1, UK=23.1, India=25.1} // Before
    {} // After 


HashMap Size
To find out how many items there are, use the size() method:

import java.util.HashMap;

public class Main {
  public static void main(String[] args) {
\\Created object capitalCities 
    HashMap<String, String> capitalCities = new HashMap<String, String>();
\\ Key , values capitalCities 
    capitalCities.put("England", "London"); // key England , Value Londo
    capitalCities.put("Germany", "Berlin");
    capitalCities.put("Norway", "Oslo");
    capitalCities.put("USA", "Washington DC");
    System.out.println(capitalCities.size());  // size() method used 
  }
}

OutPut
4

Loop Through a HashMap
Loop through the items of a HashMap with a for-each loop.

Note: Use the keySet() method if you only want the keys, and use the values() method if you only want the values:


import java.util.HashMap;
 public class Main {
  public static void main(String[] args) {

// Created object capPin
  HashMap<String, Integer> capPin = new HashMap(); // Key is string , values integer
// capPin key ,values
  capPin.put("Chennai", 100);
  capPin.put("Coimbatore", 200);
  capPin.put("Thrissur", 400);
  capPin.put("TVM", 600);
  capPin.put("Kottayam", 1000);
for (Integer i: capPin.values()) //for each loop used  values () method used to take values 
  {
  System.out.println(i);
  }
   }
   }
   
Acutall outPut
{Coimbatore=200, Chennai=100, Kottayam=1000, Thrissur=400, TVM=600}

  Used Values() OutPut is
200
100
1000
400
600



import java.util.HashMap;
 public class Main {
  public static void main(String[] args) {


// Create a HashMap object called capPin 
//Key is string , values integer
  HashMap<String, Integer> capPin = new HashMap(); 

// Add keys and values CapPin
  capPin.put("Chennai", 100);
  capPin.put("Coimbatore", 200);
  capPin.put("Thrissur", 400);
  capPin.put("TVM", 600);
  capPin.put("Kottayam", 1000);
  for (String i : capPin.keySet()) // for each loop used for keySet()
  {
  System.out.println(i);
  }
   }
   }
 

Acutall outPut
{Coimbatore=200, Chennai=100, Kottayam=1000, Thrissur=400, TVM=600}

Used keySet() outPut
Coimbatore
Chennai
Kottayam
Thrissur
TVM






import java.util.HashMap;
 public class Main {
 public static void main(String[] args) 
 {
// Create a HashMap object called Roll_Marks
 HashMap<Integer,Float> Roll_Marks = new HashMap();
// Add keys and values Roll_Marks
 Roll_Marks.put(1,35F);// Float F
 Roll_Marks.put(2,45F);
 Roll_Marks.put(3,85F);
 Roll_Marks.put(4,25F);
 for(Integer j : Roll_Marks.keySet()) // For Each Loop
 {
 // Concentated Print keys and values used get method Key & Value
 System.out.println("key: " +j+ " values " + Roll_Marks.get(j));
  }
   } 
   }
   
Out Put 
key: 1 values 35.0
key: 2 values 45.0
key: 3 values 85.0
key: 4 values 25.0




import java.util.HashMap;
public class Main {
public static void main(String[] args) {
//Create HashMap Oject people
HashMap<String, Integer> people = new HashMap();
 // Add key and values
 people.put("Evan",  5);
 people.put("Benia", 4);
 people.put("Serah", 34);
 
 // For Each loop conditon use the keSet i string which pull names to output 
 for(String i : people.keySet())
  {
  //Concatated people.get(i) to pull all record
   System.out.println("Name: " +i+" Age: " + people.get(i));
   }
    }
     }
OutPut
Name: Benia Age: 4
Name: Serah Age: 34
Name: Evan Age: 5








Java HashSet: set has to be unique.
A HashSet is a collection of items where every item is unique, and it is found in the java.util package:
Add Items
The HashSet class has many useful methods. For example, to add items to it, use the add() method:
Note: In the example above, even though BMW is added twice it only appears once in the set because every item in a set has to be unique.



import java.util.HashSet;
 public class Main {
 public static void main(String[] args) {
 
 // object created cars
 HashSet<String> cars =new HashSet();
 cars.add("Volvo"); // First volvo
 cars.add("Volvo"); // Second Volvo
 cars.add("Volvo"); // Third Volvo , HashSet has to be unique.
 cars.add("Mazda");
 cars.add("Ford");
 cars.add("BMW");
 System.out.println(cars);
 }
 }

OutPut
[Volvo, Mazda, Ford, BMW]



Check If an Item Exists
To check whether an item exists in a HashSet, use the contains() method:

import java.util.HashSet;
 public class Main {
 public static void main(String[] args) {
 
 // object created cars
 HashSet<String> cars =new HashSet();
 cars.add("Volvo");
 cars.add("Mazda");
 cars.add("Ford");
 cars.add("BMW");
 System.out.println(cars.contains("BMW")); // contains() used to find the BMW cars exits in the list
 }
 }

OutPut
True



Remove an Item
To remove an item, use the remove() method:

import java.util.HashSet;
 public class Main {
 public static void main(String[] args) {
 
 // object created cars
 HashSet<String> cars =new HashSet();
 cars.add("Volvo");
 cars.add("Mazda");
 cars.add("Ford");
 cars.add("BMW");
 cars.remove("Volvo"); // Removed the Volvo 
 System.out.println(cars); 
 }
 

OutPut
[Mazda, Ford, BMW]


To remove all items, use the clear() method:

import java.util.HashSet;
 public class Main {
 public static void main(String[] args) {
 
 // object created cars
 HashSet<String> cars =new HashSet();
 cars.add("Volvo");
 cars.add("Mazda");
 cars.add("Ford");
 cars.add("BMW");
 cars.clear(); // List will be cleared
 System.out.println(cars); 
 }
 }

OutPut
[]


HashSet Size
To find out how many items there are, use the size method:

import java.util.HashSet;
 public class Main {
 public static void main(String[] args) {
 
 // object created cars
 HashSet<String> cars =new HashSet();
 cars.add("Volvo");
 cars.add("Mazda");
 cars.add("Ford");
 cars.add("BMW");
 System.out.println(cars.size()); 
 }
 }
OutPut
4



Loop Through a HashSet
Loop through the items of an HashSet with a for-each loop:



import java.util.HashSet;
 public class Main {
 public static void main(String[] args) {
 
 // object created cars
 HashSet<String> cars =new HashSet();
 cars.add("Volvo"); 
 cars.add("Mazda");
 cars.add("Ford");
 cars.add("BMW");
 for(String c : cars) // for-each used car list 
  {
  System.out.println(c);
  }
  }
  }


OutPut
Volvo
Mazda
Ford
BMW







Other Types:
Use a HashSet that stores Integer objects:



import java.util.HashSet;
 public class Main {
 public static void main(String[] args)
 {
 // Create a HashSet object called numbers
 HashSet<Integer> number= new HashSet();
  // Add values to the set
 number.add(4);
 number.add(8);
 number.add(2);
  // Show which numbers between 1 and 10 are in the set
 for (int i = 1; i < 10; i++)
  {
  if(number.contains(i)) //contains() method used to list i 
  {
  System.out.println(i + "  <--> Found Number");
  }
  else
  {
  System.out.println(i+ " Number not Found");
  }
  }
  }
  }

OuT Put
1 Number not Found
2  <--> Found Number
3 Number not Found
4  <--> Found Number
5 Number not Found
6 Number not Found
7 Number not Found
8  <--> Found Number
9 Number not Found
 


20-03-2024

Iterator : Improved version of for loop &  for each loop which move each element and print

hasNext() - Boolean find true/false
next() - iterate each element
iterator() - method can be used to get an Iterator for any collection:



// Import the ArrayList class and the Iterator class

import java.util.ArrayList;
import java.util.Iterator;

public class Main {
public static void main(String[] args) {
// Make a collection
ArrayList<String> cars = new ArrayList();
cars.add("Jaquar");
cars.add("Land Rover");
cars.add("BMW");
cars.add("Audi");
// Get the iterator, Improved version of Loop 
Iterator<String> vechile = cars.iterator();

// Print the first item next() method used iterator in the each element
System.out.println(vechile.next());
 }
  }
  
  OutPut
Jaquar




// Import the ArrayList class and the Iterator class

import java.util.ArrayList;
import java.util.Iterator;

public class Main {
public static void main(String[] args) {
// Make a collection
ArrayList<String> cars = new ArrayList();
cars.add("Jaquar");
cars.add("Land Rover");
cars.add("BMW");
cars.add("Audi");
// Get the iterator, Improved version of Loop 
Iterator<String> vechile = cars.iterator();

// while loop used to check the collection true or false
while(vechile.hasNext())
{
// Print the first item next() method used iterator in the each element
System.out.println(vechile.next());
 }
  }
  }
  
OutPut  
Jaquar
Land Rover
BMW
Audi








Removing Items from a Collection
Iterators are designed to easily change the collections that they loop through. The remove() method can remove items from a collection while looping.

Use an iterator to remove numbers less than 10 from a collection:

import java.util.ArrayList;
import java.util.Iterator;
public class Main {
public static void main(String[] args)
 {
 ArrayList<Integer> num = new ArrayList();
 num.add(2);
 num.add(8);
 num.add(12);
 num.add(23);
 
 Iterator<Integer> it = num.iterator();
 
 while(it.hasNext())
 {
 Integer i = it.next();
 if(i < 10)
 {
 it.remove(); // remove() method used
 }
  }
  System.out.println(num);
  }
   }
 

OutPut
[12,23]



------------------------


Java Wrapper Classes

PrimitiveData Type	Wrapper Class
byte	                Byte
short	                Short
int	                Integer
long	                Long
float	                Float
double	                Double
boolean	                Boolean
char	                Character



Sometimes you must use wrapper classes, for example when working with Collection objects, such as ArrayList, where primitive types cannot be used (the list can only store objects):


Example
ArrayList<int> myNumbers = new ArrayList<int>(); // Invalid
ArrayList<Integer> myNumbers = new ArrayList<Integer>(); // Valid


Creating Wrapper Objects
To create a wrapper object, use the wrapper class instead of the primitive type. To get the value, you can just print the object:


public class Main {
  public static void main(String[] args) {
    Integer myInt = 5;
    Double myDouble = 5.99;
    Character myChar = 'A';
    System.out.println(myInt);
    System.out.println(myDouble);
    System.out.println(myChar);
  }
}

OutPut
5
5.99
A

working with objects, you can use certain methods to get information about the specific object.

For example, the following methods are used to get the value associated with the corresponding wrapper object: intValue(), byteValue(), shortValue(), longValue(), floatValue(), doubleValue(), charValue(), booleanValue().

This example will output the same result as the example above:


public class Main {
  public static void main(String[] args) {
    Integer myInt = 5;
    Double myDouble = 5.99;
    Character myChar = 'A';
    System.out.println(myInt.intValue());
    System.out.println(myDouble.doubleValue());
    System.out.println(myChar.charValue());
  }
}

OutPut:
5
5.99
A



Another useful method is the toString() method, which is used to convert wrapper objects to strings.

In the following example, we convert an Integer to a String, and use the length() method of the String class to output the length of the "string":


public class Main {
 public static void main(String[] args){
 Integer myInt = 1000;
 String myString = myInt.toString();
 System.out.println(myString.length()); // length() used which converted interger to string find to out length  
 }
  }
OutPut
4




Java try and catch
The try statement allows you to define a block of code to be tested for errors while it is being executed.

The catch statement allows you to define a block of code to be executed, if an error occurs in the try block.

The try and catch keywords come in pairs:


SyntaxGet your own Java Server
try {
  //  Block of code to try
}
catch(Exception e) {
  //  Block of code to handle errors
}



This will generate an error, because myNumbers[10] does not exist.

public class Main {
  public static void main(String[ ] args) {
    int[] myNumbers = {1, 2, 3};
    System.out.println(myNumbers[10]); // error!
  }
}
The output will be something like this:

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
        at Main.main(Main.java:4)



If an error occurs, we can use try...catch to catch the error and execute some code to handle it:

Example
public class Main {
  public static void main(String[ ] args) {
    try {
      int[] myNumbers = {1, 2, 3};
      System.out.println(myNumbers[10]);
    } catch (Exception e) {
      System.out.println("Something went wrong.");
    }
  }
}
 
 
The output will be:

Something went wrong.


Finally
The finally statement lets you execute code, after try...catch, regardless of the result:

Example
public class Main {
  public static void main(String[] args) {
    try {
      int[] myNumbers = {1, 2, 3};
      System.out.println(myNumbers[10]);
    } catch (Exception e) {
      System.out.println("Something went wrong.");
    } finally {
      System.out.println("The 'try catch' is finished.");
    }
  }
}
 
The output will be:

Something went wrong.
The 'try catch' is finished.




The throw keyword
The throw statement allows you to create a custom error.

The throw statement is used together with an exception type. There are many exception types available in Java: ArithmeticException, FileNotFoundException, ArrayIndexOutOfBoundsException, SecurityException, etc:





public class Main {
 static void checkAge(int age)
 {
 if (age < 18 )
 {
 throw new ArithmeticException("Acess Denied !! Under Age");
 }
 else
 {
 System.out.println("Access Grant!!");
 }
 }
 public static void main(String[] args)
 {
 checkAge(15);
 }
 }
OutPut
Exception in thread "main" java.lang.ArithmeticException: Acess Denied !! Under Age
	at Main.checkAge(Main.java:6)
	at Main.main(Main.java:15)





public class Main {
 static void checkAge(int age)
 {
 if (age < 18 )
 {
 throw new ArithmeticException("Acess Denied !! Under Age");
 }
 else
 {
 System.out.println("Access Grant!!");
 }
 }
 public static void main(String[] args)
 {
 checkAge(20);
 }
 }

OutPut
Access Grant!!

21-03-2024


What is a Regular Expression?
A regular expression is a sequence of characters that forms a search pattern. When you search for data in a text, you can use this search pattern to describe what you are searching for.

A regular expression can be a single character, or a more complicated pattern.

Regular expressions can be used to perform all types of text search and text replace operations.

Java does not have a built-in Regular Expression class, but we can import the java.util.regex package to work with regular expressions. The package includes the following classes:

Pattern Class - Defines a pattern (to be used in a search)
Matcher Class - Used to search for the pattern
PatternSyntaxException Class - Indicates syntax error in a regular expression pattern


Pattern.compile() method: The first parameter indicates which pattern is being searched for and the second parameter has a flag to indicates that the search should be case-insensitive. The second parameter is optional.

matcher()method: is used to search for the pattern in a string. It returns a Matcher object which contains information about the search that was performed.
find() method returns true if the pattern was found in the string and false if it was not found.

Flags
Flags in the compile() method change how the search is performed. Here are a few of them:

Pattern.CASE_INSENSITIVE - The case of letters will be ignored when performing a search.
Pattern.LITERAL - Special characters in the pattern will not have any special meaning and will be treated as ordinary characters when performing a search.
Pattern.UNICODE_CASE - Use it together with the CASE_INSENSITIVE flag to also ignore the case of letters outside of the English alphabet

Regular Expression Patterns
The first parameter of the Pattern.compile() method is the pattern. It describes what is being searched for.

Brackets are used to find a range of characters:

Expression	Description
[abc]	Find one character from the options between the brackets
[^abc]	Find one character NOT between the brackets
[0-9]	Find one character from the range 0 to 9



Example1

import java.util.regex.Pattern;
import java.util.regex.Matcher;
 public class Main {
  public static void main(String[] args) {
  Pattern pattern = Pattern.compile("Varghese Baby", Pattern.CASE_INSENSITIVE); // Pattern.compile the pattern pattern.CASE_INSENSITIVE irrecpetive upercae or lowecase match words
  Matcher matcher = pattern.matcher("Varghese Baby");
  boolean FindMatch = matcher.find(); //Finds with matcher & pattern say true or false
  if(FindMatch)
  {
  System.out.println("Match Found: Varghese Baby");
  }
  else
  {
  System.out.println("Match Not Found");
  }
  }
  }
OutPut
Match Found: Varghese Baby



Example 2

import java.util.regex.Pattern;
import java.util.regex.Matcher;
 public class Main {
  public static void main(String[] args) {
  Pattern pattern = Pattern.compile("Varghese Baby", Pattern.CASE_INSENSITIVE);
  Matcher matcher = pattern.matcher("Baby Varghese");
  boolean FindMatch = matcher.find();
  if(FindMatch)
  {
  System.out.println("Match Found: Varghese Baby");
  }
  else
  {
  System.out.println("Match Not Found: PATTERN & MATCHER miss match" );
  }
  }
  }


OutPut
Match Not Found: PATTERN & MATCHER miss match


-------------------------------------------------------------------------------------------

Pattern Square

public class Main {
  public static void main(String[] args) {
    int n=5;
    for (int i = 1; i <=5 ; i++) { // Outter Loop Start and determine as Row First hold row 1
      for (int j = 1; j <=5; j++) { // Inner Loop Startdetermine Column then coulmn prints 2,3,5 
        System.out.print("* ");
      }
   System.out.println();
   } 
   }
  }
Out Put 
Row1* * * * 
* * * * 
* * * * 
* * * *


Increasing Triangle Patten

public class Main {
  public static void main(String[] args) {
    int n=5;
    for (int i = 1; i <=n; i++) { 
      for (int j = 1; j <=i; j++) { 
        System.out.print("* ");
      }
   System.out.println();
   } 
   }
  }

OutPut
* 
* * 
* * * 
* * * * 
* * * * * 


Decreasing Triangle Pattern 

public class Main {
  public static void main(String[] args) {
    int n=5;
    for (int i = 1; i <=n; i++) { 
      for (int j = i; j <=n; j++) { 
        System.out.print("* ");
      }
   System.out.println();
   } 
   }
  }
OutPut
* * * * * 
* * * * 
* * * 
* * 
*

---------------------------------------

